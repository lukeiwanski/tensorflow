#ifndef TENSORFLOW_USE_SYCL
#error This file should only be included when compiling with SYCL support
#endif

#ifndef TENSORFLOW_KERNELS_CONV_OPS_WINOGRAD_SYCL_KERNELS_H_
#define TENSORFLOW_KERNELS_CONV_OPS_WINOGRAD_SYCL_KERNELS_H_

namespace tensorflow {
namespace functor {

template <typename T, int M, int N, int R, int S>
struct InputTile {
  static constexpr int A = M + R - 1;
  static constexpr int B = N + S - 1;
  /**
   * Read the input data from the provided input array. The pointer is assumed
   * to be at the first value that should be read into the input tile.
   *
   * The input is expected to be in the NHWC data format.
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE InputTile(_T* input, int n_cols,
                                              int n_channels, int rsize,
                                              int csize, int firstr,
                                              int firstc) {
    for (int r = 0; r < A; ++r) {
      for (int c = 0; c < B; ++c) {
        data[r][c] = (r < firstr || c < firstc || r >= rsize || c >= csize)
                         ? static_cast<_T>(0)
                         : input[(r * n_cols + c) * n_channels];
      }
    }
  }
  T data[A][B];
};
template <typename T, int M, int N, int R, int S>
struct BaseFilterTile {
  T data[R][S];
};
template <typename T, int M, int N, int R, int S, ConvType CType>
struct FilterTile;
template <typename T, int M, int N, int R, int S>
struct FilterTile<T, M, N, R, S, ConvType::Forward> final
    : public BaseFilterTile<T, M, N, R, S> {
  using BaseFilterTile<T, M, N, R, S>::data;
  /**
   * Read the filter data from the provided input array. The pointer is assumed
   * to be at the first value that should be read into the input tile.
   *
   * The input is expected to be in (Height x Width x Channel x Feature) format.
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE FilterTile(_T* input, int channel,
                                               int feature, int n_cols,
                                               int n_channels, int n_features) {
    for (int r = 0; r < R; ++r) {
      for (int c = 0; c < S; ++c) {
        int idx =
            ((r * n_cols + c) * n_channels + channel) * n_features + feature;
        data[r][c] = input[idx];
      }
    }
  }
};
template <typename T, int M, int N, int R, int S>
struct FilterTile<T, M, N, R, S, ConvType::InputBackprop> final
    : public BaseFilterTile<T, M, N, R, S> {
  using BaseFilterTile<T, M, N, R, S>::data;
  /**
   * Read the filter data from the provided input array but mirror the filter
   * for use in backprop. The pointer is assumed to be at the first value that
   * should be read into the input tile.
   *
   * The input is expected to be in (Height x Width x Channel x Feature) format.
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE FilterTile(
      _T const* input, int const channel, int const feature, int const n_cols,
      int const n_channels, int const n_features) {
    for (int r = 0; r < R; ++r) {
      for (int c = 0; c < S; ++c) {
        // Here the transforms (R - 1 - r) and (S - 1 - c) mirror the filter
        // data. Note that the channel and feature dims were switched in the
        // kernel params.
        int idx =
            (((R - 1 - r) * n_cols + (S - 1 - c)) * n_features + feature) *
                n_channels +
            channel;
        data[r][c] = input[idx];
      }
    }
  }
};
template <typename T, int M, int N, int R, int S>
struct FilterTile<T, M, N, R, S, ConvType::FilterBackprop> final
    : public BaseFilterTile<T, M, N, R, S> {
  using BaseFilterTile<T, M, N, R, S>::data;
  /**
   * Read the filter data from the provided input array.
   *
   * The input is expected to be in (Batch x Height x Width x Feature) format.
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE FilterTile(_T const* input,
                                               SYCLOutputWindow const& w,
                                               int const n_cols,
                                               int const n_features) {
    input += w.offset;
    for (int r = 0; r < R; ++r) {
      for (int c = 0; c < S; ++c) {
        int idx = (r * n_cols + c) * n_features;
        data[r][c] =
            (r >= w.rsize || c >= w.csize) ? static_cast<_T>(0) : input[idx];
      }
    }
  }
};
/**
 * Base class for the output tile which provides a correctly sized data array.
 */
template <typename T, int M, int N, int R, int S>
struct BaseTransformedFilterTile {
  static constexpr int A = M + R - 1;
  static constexpr int B = N + S - 1;
  T data[A][B];
};
/**
 * Tile which transforms the intermediate layer into the output layer. Should be
 * specialised for each Winograd tranform.
 *
 * This object needs to provide the following constructor:
 *
 *   template <bool mirror>
 *   TransformedFilterTile(FilterTile<T, 2, 2, 3, 3, mirror> const& filter)
 *       : BaseTransformedFilterTile<T, 2, 2, 3, 3>{} {
 *     // Implement the filter Winograd transform
 *   }
 *
 * and needs to provide access to the base class data array with:
 *
 *   using BaseTransformedFilterTile<T, 2, 2, 3, 3>::data;
 */
template <typename T, int M, int N, int R, int S>
struct TransformedFilterTile;
/**
 * Base class for the output tile which provides a correctly sized data array.
 */
template <typename T, int M, int N, int R, int S>
struct BaseTransformedInputTile {
  static constexpr int A = M + R - 1;
  static constexpr int B = N + S - 1;
  T data[A][B];
};
/**
 * Tile which transforms the intermediate layer into the output layer. Should be
 * specialised for each Winograd tranform.
 *
 * This object needs to provide the following constructor:
 *
 *   TransformedInputTile(InputTile<T, 2, 2, 3, 3> const& inp)
 *       : BaseTransformedInputTile<T, 2, 2, 3, 3>{} {
 *     // Implement the input Winograd transform
 *   }
 *
 * and needs to provide access to the base class data array with:
 *
 *   using BaseTransformedInpuTile<T, 2, 2, 3, 3>::data;
 */
template <typename T, int M, int N, int R, int S>
struct TransformedInputTile;
/**
 * Tile to store the intermediate Winograd data. Provides an update method to
 * increment the tile with provided transformed inputs and filters.
 */
template <typename T, int M, int N, int R, int S>
struct IntermediateTile {
  static constexpr int A = M + R - 1;
  static constexpr int B = N + S - 1;
  inline TF_ATTRIBUTE_ALWAYS_INLINE IntermediateTile() {
    for (int i = 0; i < A; ++i) {
      for (int j = 0; j < B; ++j) {
        data[i][j] = static_cast<T>(0);
      }
    }
  }
  /**
   * Read the intermediate tile from a temporary buffer. The input shape is
   * expected to be
   *   [ (M+R-1)(N+S-1), features, (batch * tile_rows * tile_cols) ].
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE IntermediateTile(_T* input,
                                                     int const tile_idx,
                                                     int const n_tiles,
                                                     int const feature,
                                                     int const n_features) {
    input += feature * n_tiles + tile_idx;
    for (int r = 0; r < A; ++r) {
      for (int c = 0; c < B; ++c) {
        data[r][c] = *input;
        input += n_features * n_tiles;
      }
    }
  }
  inline TF_ATTRIBUTE_ALWAYS_INLINE void update(
      TransformedInputTile<T, M, N, R, S> const& inp,
      TransformedFilterTile<T, M, N, R, S> const& filter) {
    for (int r = 0; r < A; ++r) {
      for (int c = 0; c < B; ++c) {
        data[r][c] += inp.data[r][c] * filter.data[r][c];
      }
    }
  }
  T data[A][B];
};
/**
 * Base class for the output tile which provides a correctly sized data array.
 */
template <typename T, int M, int N, int R, int S>
struct BaseOutputTile {
  T data[M][N];
};
/**
 * Tile which transforms the intermediate layer into the output layer. Should be
 * specialised for each Winograd tranform.
 *
 * This object needs to provide the following constructor:
 *
 *   OutputTile(IntermediateTile<T, M, N, R, S> const& tile)
 *       : BaseOutputTile<T, M, N, R, S>{} {
 *     // Implement the inverse Winograd transform
 *   }
 *
 * and needs to provide access to the base class data array with:
 *
 *   using BaseOutputTile<T, M, N, R, S>::data;
 */
template <typename T, int M, int N, int R, int S>
struct OutputTile;
template <typename T, int M, int N, int R, int S>
struct OutputData {
  static constexpr int A = M + R - 1;
  static constexpr int B = N + S - 1;
  using Index = int;
  /**
   * Write the transformed input tile to a temporary buffer where each entry of
   * the tile is split into separate matrices. The output pointer should be at
   * the start of the temporary buffer.
   *
   * The resulting temporary buffer will be written as a batch of these
   * matrices, with a shape of
   *   [ (M+R-1)*(N+S-1), (batch * row_tiles * col_tiles), channels ].
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE static void write_transformed_input(
      _T* output, Index const tile_idx, Index const channel,
      Index const n_tiles, Index const n_channels,
      TransformedInputTile<T, M, N, R, S> const& tile) {
    output += tile_idx * n_channels + channel;
    for (int r = 0; r < A; ++r) {
      for (int c = 0; c < B; ++c) {
        *output = tile.data[r][c];
        output += n_tiles * n_channels;
      }
    }
  }
  /**
   * Write the transformed filter tile to a temporary buffer where each entry of
   * the tile is split into separate matrices. The output pointer should be at
   * the start of the temporary buffer.
   *
   * The resulting temporary buffer will be written as a batch of these
   * matrices, with a shape of
   *   [ (M+R-1)*(N+S-1), features, channels ].
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE static void write_transformed_filter(
      _T* output, Index const channel, Index const feature,
      Index const n_channels, Index const n_features,
      TransformedFilterTile<T, M, N, R, S> const& tile) {
    output += feature * n_channels + channel;
    for (int r = 0; r < A; ++r) {
      for (int c = 0; c < B; ++c) {
        *output = tile.data[r][c];
        output += n_features * n_channels;
      }
    }
  }
  /**
   * Write the output tile to the correct output memory. The output pointer
   * should be at the start of the output buffer. The resulting output shape is
   * NHWC.
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE static void write_output(
      _T* output, SYCLOutputWindow const& window, Index const n_cols,
      Index const n_channels, OutputTile<T, M, N, R, S> const& tile) {
    output += window.offset;
    for (int r = 0; r < M && r < window.rsize; ++r) {
      for (int c = 0; c < N && c < window.csize; ++c) {
        output[(r * n_cols + c) * n_channels] = tile.data[r][c];
      }
    }
  }
  /**
   * Write the output tile to the correct output memory. The output pointer
   * should be at the start of the output buffer. The resulting output shape is
   * NHWC.
   *
   * NOTE: The template here allows different address space attributes to be
   * passed with the pointer, rather than specifying the pointer will be to
   * global memory or to local memory.
   */
  template <typename _T>
  inline TF_ATTRIBUTE_ALWAYS_INLINE static void write_filter_output(
      _T* output, Index const channel, Index const feature,
      Index const n_channels, Index const n_features,
      OutputTile<T, M, N, R, S> const& tile) {
    output += channel * n_features + feature;
    for (int r = 0; r < M; ++r) {
      for (int c = 0; c < N; ++c) {
        *output = tile.data[r][c];
        output += n_channels * n_features;
      }
    }
  }
};
/**
 * Kernel function object to compute the forward pass of a convolution using a
 * simple Winograd transform. This kernel will perform all the computation in
 * the convolution.
 */
template <typename T, int M, int N, int R, int S, ConvType CType>
struct WinogradConv {
  using Index = int;
  using buffer_data = uint8_t;
  static constexpr auto read_mode = cl::sycl::access::mode::read;
  static constexpr auto write_mode = cl::sycl::access::mode::discard_write;
  static constexpr auto global_access = cl::sycl::access::target::global_buffer;
  using write_accessor =
      cl::sycl::accessor<buffer_data, 1, write_mode, global_access>;
  using read_accessor =
      cl::sycl::accessor<buffer_data, 1, read_mode, global_access>;

  inline TF_ATTRIBUTE_ALWAYS_INLINE WinogradConv(Index const n_tiles,
                                                 SYCLConv2DParams const& params,
                                                 read_accessor const input,
                                                 read_accessor const kernel,
                                                 write_accessor output)
      : n_tiles_{n_tiles},
        p_{params},
        input_accessor_{input},
        kernel_accessor_{kernel},
        output_accessor_{output} {}

  inline TF_ATTRIBUTE_ALWAYS_INLINE void operator()(cl::sycl::item<1> item) {
    Index index = item.get(0);
    if (index < n_tiles_) {
      const T* input_data = ConvertToActualTypeSycl(T, input_accessor_);
      const T* kernel_data = ConvertToActualTypeSycl(T, kernel_accessor_);
      T* output_data = ConvertToActualTypeSycl(T, output_accessor_);

      const Index feature = index % p_.features_;
      const Index tile_idx = index / p_.features_;
      const SYCL2DWindow w = p_.winograd_input_window<M, N, R, S>(
          tile_idx, CType == ConvType::InputBackprop);

      IntermediateTile<T, M, N, R, S> tmp{};

      for (Index channel = 0; channel < p_.channels_; ++channel) {
        const Index offset =
            ((w.batch * p_.in_rows_ + w.rstart) * p_.in_cols_ + w.cstart) *
                p_.channels_ +
            channel;
        InputTile<T, M, N, R, S> inp(input_data + offset, p_.in_cols_,
                                     p_.channels_, w.rend - w.rstart,
                                     w.cend - w.cstart, w.firstr, w.firstc);
        FilterTile<T, M, N, R, S, CType> filter(kernel_data, channel, feature,
                                                p_.window_cols_, p_.channels_,
                                                p_.features_);
        tmp.update(TransformedInputTile<T, M, N, R, S>{inp},
                   TransformedFilterTile<T, M, N, R, S>{filter});
      }
      SYCLOutputWindow out_w = p_.winograd_output_index<M, N, R, S>(index);
      OutputData<T, M, N, R, S>::write_output(output_data, out_w, p_.out_cols_,
                                              p_.features_,
                                              OutputTile<T, M, N, R, S>{tmp});
    }
  }

 private:
  const Index n_tiles_;
  const SYCLConv2DParams p_;
  const read_accessor input_accessor_;
  const read_accessor kernel_accessor_;
  write_accessor output_accessor_;
};
template <typename T, int M, int N, int R, int S, ConvType CType>
struct ExtractInputTiles {
  using Index = int;
  using buffer_data = uint8_t;
  static constexpr auto read_mode = cl::sycl::access::mode::read;
  static constexpr auto write_mode = cl::sycl::access::mode::discard_write;
  static constexpr auto global_access = cl::sycl::access::target::global_buffer;
  using write_accessor =
      cl::sycl::accessor<buffer_data, 1, write_mode, global_access>;
  using read_accessor =
      cl::sycl::accessor<buffer_data, 1, read_mode, global_access>;

  inline TF_ATTRIBUTE_ALWAYS_INLINE ExtractInputTiles(
      Index const n_threads, Index const n_tiles,
      SYCLConv2DParams const& params, read_accessor const input,
      write_accessor output)
      : n_threads_{n_threads},
        n_tiles_{n_tiles},
        p_{params},
        input_accessor_{input},
        output_accessor_{output} {}

  inline TF_ATTRIBUTE_ALWAYS_INLINE void operator()(cl::sycl::item<1> item) {
    Index index = item.get(0);
    if (index < n_threads_) {
      const T* input_data = ConvertToActualTypeSycl(T, input_accessor_);
      T* output_data = ConvertToActualTypeSycl(T, output_accessor_);

      const Index n_tile_rows = RoundRatioUpAboveZero(p_.out_rows_, M);
      const Index n_tile_cols = RoundRatioUpAboveZero(p_.out_cols_, N);
      const Index channel_idx = index % p_.channels_;
      const Index tile_idx = index / p_.channels_;

      Index batch = tile_idx;
      const Index cstart = (batch % n_tile_cols) * N - p_.pad_cols_;
      const Index cend = std::min(cstart + N + S - 1, p_.in_cols_);
      const Index firstc = cstart < 0 ? -cstart : 0;
      batch /= n_tile_cols;

      const Index rstart = (batch % n_tile_rows) * M - p_.pad_rows_;
      const Index rend = std::min(rstart + M + R - 1, p_.in_rows_);
      const Index firstr = rstart < 0 ? -rstart : 0;
      batch /= n_tile_rows;

      const Index offset =
          ((batch * p_.in_rows_ + rstart) * p_.in_cols_ + cstart) *
              p_.channels_ +
          channel_idx;
      InputTile<T, M, N, R, S> inp(input_data + offset, p_.in_cols_,
                                   p_.channels_, rend - rstart, cend - cstart,
                                   firstr, firstc);

      OutputData<T, M, N, R, S>::write_transformed_input(
          output_data, index / p_.channels_, channel_idx, n_tiles_,
          p_.channels_, TransformedInputTile<T, M, N, R, S>{inp});
    }
  }

 private:
  const Index n_threads_;
  const Index n_tiles_;
  const SYCLConv2DParams p_;
  const read_accessor input_accessor_;
  write_accessor output_accessor_;
};
template <typename T, int M, int N, int R, int S>
struct ExtractInputTiles<T, M, N, R, S, ConvType::FilterBackprop> {
  using Index = int;
  using buffer_data = uint8_t;
  static constexpr auto read_mode = cl::sycl::access::mode::read;
  static constexpr auto write_mode = cl::sycl::access::mode::discard_write;
  static constexpr auto global_access = cl::sycl::access::target::global_buffer;
  using write_accessor =
      cl::sycl::accessor<buffer_data, 1, write_mode, global_access>;
  using read_accessor =
      cl::sycl::accessor<buffer_data, 1, read_mode, global_access>;

  inline TF_ATTRIBUTE_ALWAYS_INLINE ExtractInputTiles(
      Index const n_threads, Index const n_tile_rows, Index const n_tile_cols,
      SYCLConv2DParams const& params, read_accessor const input,
      write_accessor output)
      : n_threads_{n_threads},
        n_tile_rows_{n_tile_rows},
        n_tile_cols_{n_tile_cols},
        p_{params},
        input_accessor_{input},
        output_accessor_{output} {}

  inline TF_ATTRIBUTE_ALWAYS_INLINE void operator()(cl::sycl::item<1> item) {
    Index index = item.get(0);
    if (index < n_threads_) {
      const T* input_data = ConvertToActualTypeSycl(T, input_accessor_);
      T* output_data = ConvertToActualTypeSycl(T, output_accessor_);

      const Index channel_idx = index % p_.channels_;
      const Index tile_idx = index / p_.channels_;

      Index batch = tile_idx;
      const Index cstart = (batch % n_tile_cols_) * S - p_.pad_cols_;
      const Index cend = std::min(cstart + N + S - 1, p_.in_cols_);
      const Index firstc = cstart < 0 ? -cstart : 0;
      batch /= n_tile_cols_;

      const Index rstart = (batch % n_tile_rows_) * R - p_.pad_rows_;
      const Index rend = std::min(rstart + M + R - 1, p_.in_rows_);
      const Index firstr = rstart < 0 ? -rstart : 0;
      batch /= n_tile_rows_;

      const Index offset =
          ((batch * p_.in_rows_ + rstart) * p_.in_cols_ + cstart) *
              p_.channels_ +
          channel_idx;
      InputTile<T, M, N, R, S> inp(input_data + offset, p_.in_cols_,
                                   p_.channels_, rend - rstart, cend - cstart,
                                   firstr, firstc);
      TransformedInputTile<T, M, N, R, S> trans{inp};

      const Index n_tiles = p_.batch_ * n_tile_rows_ * n_tile_cols_;
      OutputData<T, M, N, R, S>::write_transformed_input(
          output_data, tile_idx, channel_idx, n_tiles, p_.channels_, trans);
    }
  }

 private:
  const Index n_threads_;
  const Index n_tile_rows_;
  const Index n_tile_cols_;
  const SYCLConv2DParams p_;
  const read_accessor input_accessor_;
  write_accessor output_accessor_;
};
template <typename T, int M, int N, int R, int S, ConvType CType>
struct ExtractKernelTiles {
  using Index = int;
  using buffer_data = uint8_t;
  static constexpr auto read_mode = cl::sycl::access::mode::read;
  static constexpr auto write_mode = cl::sycl::access::mode::discard_write;
  static constexpr auto global_access = cl::sycl::access::target::global_buffer;
  using write_accessor =
      cl::sycl::accessor<buffer_data, 1, write_mode, global_access>;
  using read_accessor =
      cl::sycl::accessor<buffer_data, 1, read_mode, global_access>;

  inline TF_ATTRIBUTE_ALWAYS_INLINE ExtractKernelTiles(
      Index const n_threads, Index const /*n_tiles*/,
      SYCLConv2DParams const& params, read_accessor const kernel,
      write_accessor output)
      : n_threads_{n_threads},
        p_{params},
        kernel_accessor_{kernel},
        output_accessor_{output} {}

  inline TF_ATTRIBUTE_ALWAYS_INLINE void operator()(cl::sycl::item<1> item) {
    Index index = item.get(0);
    if (index < n_threads_) {
      const T* kernel_data = ConvertToActualTypeSycl(T, kernel_accessor_);
      T* output_data = ConvertToActualTypeSycl(T, output_accessor_);

      const Index feature_idx = index % p_.features_;
      const Index channel_idx = (index / p_.features_) % p_.channels_;

      FilterTile<T, M, N, R, S, CType> filter(kernel_data, channel_idx,
                                              feature_idx, p_.window_cols_,
                                              p_.channels_, p_.features_);
      TransformedFilterTile<T, M, N, R, S> transformed{filter};

      OutputData<T, M, N, R, S>::write_transformed_filter(
          output_data, channel_idx, feature_idx, p_.channels_, p_.features_,
          transformed);
    }
  }

 private:
  const Index n_threads_;
  const SYCLConv2DParams p_;
  const read_accessor kernel_accessor_;
  write_accessor output_accessor_;
};
template <typename T, int M, int N, int R, int S>
struct ExtractKernelTiles<T, M, N, R, S, ConvType::FilterBackprop> {
  using Index = int;
  using buffer_data = uint8_t;
  static constexpr auto CType = ConvType::FilterBackprop;
  static constexpr auto read_mode = cl::sycl::access::mode::read;
  static constexpr auto write_mode = cl::sycl::access::mode::discard_write;
  static constexpr auto global_access = cl::sycl::access::target::global_buffer;
  using write_accessor =
      cl::sycl::accessor<buffer_data, 1, write_mode, global_access>;
  using read_accessor =
      cl::sycl::accessor<buffer_data, 1, read_mode, global_access>;

  inline TF_ATTRIBUTE_ALWAYS_INLINE ExtractKernelTiles(
      Index const n_threads, Index const n_tiles,
      SYCLConv2DParams const& params, read_accessor const kernel,
      write_accessor output)
      : n_threads_{n_threads},
        n_tiles_{n_tiles},
        p_{params},
        kernel_accessor_{kernel},
        output_accessor_{output} {}

  inline TF_ATTRIBUTE_ALWAYS_INLINE void operator()(cl::sycl::item<1> item) {
    Index index = item.get(0);
    if (index < n_threads_) {
      const T* kernel_data = ConvertToActualTypeSycl(T, kernel_accessor_);
      T* output_data = ConvertToActualTypeSycl(T, output_accessor_);

      const Index feature = index % p_.features_;
      const Index tile_idx = index / p_.features_;

      SYCLOutputWindow w =
          p_.winograd_kernel_from_tile<M, N, R, S>(tile_idx, feature);

      FilterTile<T, M, N, R, S, CType> filter(kernel_data, w, p_.window_cols_,
                                              p_.features_);
      TransformedFilterTile<T, M, N, R, S> transformed{filter};

      OutputData<T, M, N, R, S>::write_transformed_filter(
          output_data, feature, tile_idx, p_.features_, n_tiles_, transformed);
    }
  }

 private:
  const Index n_threads_;
  const Index n_tiles_;
  const SYCLConv2DParams p_;
  const read_accessor kernel_accessor_;
  write_accessor output_accessor_;
};
template <typename T, int M, int N, int R, int S, ConvType CType>
struct ExtractOutputTiles {
  using Index = int;
  using buffer_data = uint8_t;
  static constexpr auto read_mode = cl::sycl::access::mode::read;
  static constexpr auto write_mode = cl::sycl::access::mode::discard_write;
  static constexpr auto global_access = cl::sycl::access::target::global_buffer;
  using write_accessor =
      cl::sycl::accessor<buffer_data, 1, write_mode, global_access>;
  using read_accessor =
      cl::sycl::accessor<buffer_data, 1, read_mode, global_access>;

  inline TF_ATTRIBUTE_ALWAYS_INLINE ExtractOutputTiles(
      Index const n_threads, Index const n_tiles,
      SYCLConv2DParams const& params, read_accessor const input,
      write_accessor output)
      : n_threads_{n_threads},
        n_tiles_{n_tiles},
        p_{params},
        input_accessor_{input},
        output_accessor_{output} {}

  inline TF_ATTRIBUTE_ALWAYS_INLINE void operator()(cl::sycl::item<1> item) {
    Index index = item.get(0);
    if (index < n_threads_) {
      const T* input_data = ConvertToActualTypeSycl(T, input_accessor_);
      T* output_data = ConvertToActualTypeSycl(T, output_accessor_);

      const Index tile_idx = index % n_tiles_;
      const Index feature = index / n_tiles_;

      IntermediateTile<T, M, N, R, S> tmp{input_data, tile_idx, n_tiles_,
                                          feature, p_.features_};
      SYCLOutputWindow out_w =
          p_.winograd_output_index<M, N, R, S>(tile_idx, feature);
      OutputData<T, M, N, R, S>::write_output(output_data, out_w, p_.out_cols_,
                                              p_.features_,
                                              OutputTile<T, M, N, R, S>{tmp});
    }
  }

 private:
  const Index n_threads_;
  const Index n_tiles_;
  const SYCLConv2DParams p_;
  const read_accessor input_accessor_;
  write_accessor output_accessor_;
};
template <typename T, int M, int N, int R, int S>
struct ExtractOutputTiles<T, M, N, R, S, ConvType::FilterBackprop> {
  using Index = int;
  using buffer_data = uint8_t;
  static constexpr auto read_mode = cl::sycl::access::mode::read;
  static constexpr auto write_mode = cl::sycl::access::mode::discard_write;
  static constexpr auto global_access = cl::sycl::access::target::global_buffer;
  using write_accessor =
      cl::sycl::accessor<buffer_data, 1, write_mode, global_access>;
  using read_accessor =
      cl::sycl::accessor<buffer_data, 1, read_mode, global_access>;

  inline TF_ATTRIBUTE_ALWAYS_INLINE ExtractOutputTiles(
      Index const n_threads, Index const /*n_tiles*/,
      SYCLConv2DParams const& params, read_accessor const input,
      write_accessor output)
      : n_threads_{n_threads},
        p_{params},
        input_accessor_{input},
        output_accessor_{output} {}

  inline TF_ATTRIBUTE_ALWAYS_INLINE void operator()(cl::sycl::item<1> item) {
    Index index = item.get(0);
    if (index < n_threads_) {
      const T* input_data = ConvertToActualTypeSycl(T, input_accessor_);
      T* output_data = ConvertToActualTypeSycl(T, output_accessor_);

      const Index feature = index % p_.features_;
      const Index channel = index / p_.features_;

      IntermediateTile<T, M, N, R, S> tmp{input_data, feature, p_.features_,
                                          channel, p_.channels_};
      OutputData<T, M, N, R, S>::write_filter_output(
          output_data, channel, feature, p_.channels_, p_.features_,
          OutputTile<T, M, N, R, S>{tmp});
    }
  }

 private:
  const Index n_threads_;
  const SYCLConv2DParams p_;
  const read_accessor input_accessor_;
  write_accessor output_accessor_;
};
}  // namespace functor
}  // namespace tensorflow
#endif  // TENSORFLOW_KERNELS_CONV_OPS_WINOGRAD_SYCL_KERNELS_H_
